# Розрахункова-графічна робота

## з дисципліни «Архітектура та проєктування програмного забезпечення»
## на тему: «ШАБЛОНИ ПРОГРАМУВАННЯ»

# CREATIONAL PATTERN (OBJECT POOL)
## Опис шаблону:
### Шаблон пулу об’єктів – це шаблон створення програмного забезпечення, який використовується в ситуаціях, коли вартість ініціалізації екземпляра класу дуже висока. По суті, пул об’єктів – це контейнер, який містить певну кількість об’єктів. Отже, коли об’єкт взято з пулу, він недоступний у пулі, доки його не повернуть назад. [1]
### Об’єкти в пулі мають наступний життєвий цикл:
*	Створення;
*	Перевірка;
*	Знищення.

### Для шаблону ObjectPool була створена Mermaid діаграма (див. рисунок 1):

### Елементи шаблону:
Клієнт: це клас, який використовує об’єкт з пулу.
ReuseablePool: об’єкт пулу є дорогим або повільним для створення екземплярів або має обмежену доступність, тому його слід зберігати в пулі об’єктів.
ObjectPool: клас Pool є найважливішим класом у шаблоні проектування пулу об’єктів. ObjectPool підтримує список доступних об’єктів і колекцію об’єктів, які вже були запрошені з пулу. [1]

### Цей шаблон використовується, коли потрібно розподілити або перерозподілити багато об'єктів; також, коли ми знаємо, що у нас є обмежена кількість об'єктів, які будуть в пам'яті одночасно.
### Переваги:
*	Значний приріст продуктивності;
*	Шаблон керує з'єднаннями і надає можливість повторного використання та спільного доступу до них;
*	Сприяє пришвидшенню розподілу об’єктів.
### Недоліки [2]:
*	Пул може витрачати пам'ять на непотрібні об'єкти;
*	Лише фіксована кількість об’єктів може бути активною в будь-який момент часу;
*	Розмір пам'яті для кожного об'єкта фіксований;
*	Невикористані об'єкти залишаться в пам'яті;
*	Повторно використані об’єкти не очищаються автоматично.
### Особливості використання:
Пул нічого не знає про реалізацію об'єктів, які зберігаються. Тому вважається, що повернений об'єкт знаходиться в невизначеному стані. Для подальшого використання його необхідно перевести в початковий стан (скидання). Наявність об'єктів в невизначеному стані перетворює Пул в «об'єктну клоаку» (object cesspool). Повторне використання може стати причиною витоку конфіденційної інформації. Тому обов'язково необхідно зчищати поля з секретними даними при скиданні, а самі дані — знищувати. [3]
### Можлива ситуація, коли в Пулі не залишиться вільних об'єктів. В такому випадку, реакція на запит може бути наступною:
#### 1.	Збільшення розміру пула;
#### 2.	Відмова у видачі об'єкта;
#### 3.	Становлення в чергу і очікування звільнення об'єкта.
### Коли ви закінчите роботу з об'єктом у пулі, ви повинні не забути покласти його назад у пул. Це звучить просто, доки ви не зрозумієте, що якщо ви забудете, то не отримаєте практично ніякого зворотного зв'язку, який би вас про це попередив. Не буде помилки компілятора або попередження, не буде надруковано логів налагодження, і гра не вилетить. Просто перезаписавши змінну, ви звільните об'єкт, на який вона посилається, і врешті-решт відбудеться збір сміття. [2]

# STRUCTURUAL PATTERN (Bridge)
## Опис шаблону:
### Шаблон проєктування Bridge призначений для «відокремлення абстракції від її реалізації, щоб вони могли змінюватися незалежно». Міст використовує інкапсуляцію, агрегацію та може використовувати успадкування для розподілу обов’язків на різні класи. [4]
Шаблон Bridge дозволяє розробляти абстракцію та реалізацію незалежно, і клієнтський код може отримати доступ лише до частини абстракції, не турбуючись про частину реалізації.
Абстракція – це інтерфейс, або абстрактний клас, а реалізатор – це також інтерфейс або абстрактний клас.
Абстракція містить посилання на реалізатор. Нащадки абстракції називаються уточненими абстракціями, а нащадки реалізатора – конкретними реалізаторами. Оскільки ми можемо змінювати посилання на реалізатор в абстракції, ми можемо змінювати реалізатор абстракції під час виконання програми. Зміни в реалізаторі не впливають на клієнтський код. Це збільшує вільний зв'язок між абстракцією класу та його реалізацією. [5]
### Для шаблону Bridge була створена Mermaid діаграма (див. рисунок 2):


### Елементи шаблону:
* Абстракція – ядро шаблону проєктування мосту, що визначає суть. Містить посилання на реалізатор.
* Уточнена абстракція – розширює абстракцію, забираючи більш дрібні деталі на один рівень нижче. Приховує більш дрібні елементи від реалізаторів.
* Реалізатор – визначає інтерфейс для класів реалізації. Цей інтерфейс не обов'язково повинен відповідати безпосередньо інтерфейсу абстракції і може дуже сильно відрізнятися. Абстракція imp забезпечує реалізацію з точки зору операцій, що надаються інтерфейсом реалізатора.
* Конкретна реалізація – реалізує вищезгаданий реалізатор, надаючи конкретну реалізацію. [5]


### Шаблон Bridge – корисний, коли і клас, і те, що він робить, часто змінюються.
### Особливості використання:
Шаблон Bridge використовується, коли:
* необхідно розділити та організувати монолітний клас, який має кілька варіантів певної функціональності (наприклад, якщо клас може працювати з різними серверами баз даних);
*	розширити клас у кількох ортогональних (незалежних) вимірах;
* потрібно мати можливість перемикати реалізації під час виконання.
Переваги:
* Можна створювати незалежні від платформи класи та програми;
* Клієнтський код працює з абстракціями високого рівня. Він не піддається впливу деталей платформи;
* Відкритий/закритий принцип. Можна вводити нові абстракції та реалізації незалежно одна від одної;
* Принцип єдиної відповідальності. Можна зосередитися на лозіці високого рівня в абстракції та на деталях платформи в реалізації.
Недоліки:
* Є ризик зробити код більш складним, застосувавши шаблон до дуже згуртованого класу. [6]


